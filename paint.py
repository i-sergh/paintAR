
"""
PaintAR !
Открывает 2 графических окна (холст, камера) и одно консольное

Скрипт подключается к камере, находит требуемые цвета:
    - красный,
    - оранжевый,
    - желтый,
    - лаймовый,
    - синий,
    - розовый

По найденным цветам находит контуры.

Залитые контуры отрисовывает в окне "paint"
В окне "camera" выводит изображение с камеры, выделяя найденные контуры соответствующими цветами

 управление по клавишам (сделайте любое графическое окно активным нажав на него курсором мыши):
 
 ДЛЯ ОЧИСТКИ ХОЛСТА нажмите пробел

 ДЛЯ ЗАВЕРШЕНИЯ ПРИЛОЖЕНИЯ нажмите ESC

ВОЗМОЖНЫЕ ОШИБКИ!!!
 - нет камеры
 - камера не подключена
 - камера занята иным приложнием
 - при работе приложения, пк был погружен в сон, что привело к некорректному завершению приложения
        Лечение: закройте консольное окно, если оно еще открыто

██ ▇▇ ▆ ▅ ▄ ▃ ▂ ▁▁▁ ▂ ▃ ▄ ▅ ▆ ▇▇ █▉
▉                                 ▉ 
▉         made by i-sergh         ▉
▉                                 ▉
▉ https://www.github.com/i-sergh/ ▉
▍     ▐             ▐             ▐
     ▏       ▐         ▐    ▐ 
▏          ▏      ▏      ▏    ▏  ▏
   ▏   ▏        ▏   ▏           

"""

# подключение библиотеки компьютерного зрения
import cv2
# подключение библиотеки для работы с массивами
# позволяет работать с массивами си, что заметно ускоряет вычисления
import numpy as np


print(__doc__)

# создаем массив нулей по размеру окна камеры 
# по умолчанию камера имеет следующие размеры:
# высота 480px
# ширина 640px
# количество цветовых каналов 3
# библиотека cv2 работает с цветовым пространством BGR
#   это RGB, но красный и синий поменялись местами
cnv = np.zeros( (480, 640, 3), dtype=np.uint8())


# Получаем изображение с видеопотока
# Значение, идущее на вход конструктора класса VideoCapture ( в нашем случае это цифра 0 )
#   это индекс камеры в компьютере 
#       Если камера одна, то её индекс 0
#       Если камер несколько, то индекс каждой идёт по порядку, начиная с нуля

cap = cv2.VideoCapture(0)


# к этой функции советую вернуться после её вызова :P
# а пока, советую её пропустить
def findAndDrawContour(hsv: np.array, out: np.array, cnv: np.array,
                         clr_low: tuple, clr_high: tuple, clr: tuple, zap:True=False):

    """
    функция выполняет сразу две задачи:
        - найти контуры выбранного цветового промежутка
        - отрисовать найденные контуры на холсте и камере

    hsv - массив numpy, кадр с камеры в формате hsv

    out - массив numpy, выходной массив камеры, на нём отрисовываются контуры

    cnv - массив numpy, выходной массив холста, на нём отрисовываются залитые контуры

    clr_low - кортеж из трех значений, минимальное значение цветового спектра в формате HSV

    clr_high - кортеж из трех значений, максимальное значение цветового спектра в формате HSV

        все значения в кортеже clr_low меньше соответствующему ему по индексу значения в кортеже clr_high
        иначе не найдёт цвет вообще
    
    clr - кортеж из трех значений, цвет контуров на холсте и камере в формате BGR

    zap - супер секретный режим работы !!
    """

    # находим маску цвета на сизображении с камеры (переменная hsv) по указанным промежуткам
    # mssk - двумерный numpy массив по высоте и ширене соответствует окну камеры
    # так как массив двумерный, хранит в себе всего один цветовой канал    
    mask = cv2.inRange(hsv, clr_low, clr_high)
    

    # находим контуры на изображении по нашей маске
    # дополнительные константы в данном случае большой роли не играют
    # список найденных контуров записан в переменную cont
    # h - переменная иерархии контуров; нужна, если нам важно, какой контур находится внутри иного
    cont, h = cv2.findContours( mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE )

    # проверяем, что найдены хоть какие-то контуры выделенного цвета
    if len(cont)> 0:
        # проходимся по списку контуров   
        for i in range( len(cont)):
            # если площадь текущего контура больше 500px (а это не очень большой обьект)
            if cv2.contourArea(cont[i]) > 500:
                # то мы отрисовываем его на камере толщиной в 2 пикселя
                cv2.drawContours(out, cont, i, clr, 2)
                if zap:
                    # ой, что это? Секретный режим?!
                    cv2.drawContours(cnv, cont, i, clr, 2)
                else:
                    # и на холсте полностью залитым
                    cv2.drawContours(cnv, cont, i, clr, -1)
                


# для постоянной обработки видеопотокаи вывода на экран изображения используем бесконечный цикл
while True:

    # получаем информацию с видеопотока
    # frame - массив изображения кадра в формате массивов numpy
    # tr - удачное/неудачное чтение изображения
    #   удалось считать - True
    #   не удалось -  False. 
    #       Например, если физически выдернуть камеру       | <- две наиболее распространённые ошибки
    #       или камера изначально занята другим приложением |    при работе с камерой
    tr, frame = cap.read()

    #  для того, чтобы камера выглядела как зеркало, её нужно отразить
    frame = cv2.flip(frame, 2)

    # размытие blur - маленькая магия:
    # если пытаться найти цвет напрямую, то будет очень много неприятных шумов
    # шумы можно сгладить размытием
    # здесь размытие со здвигом по x на 10px и по y на 10px
    frame_blur = cv2.blur(frame, (10,10) )
    
    # Когда мы хотим найти цвет, на самом деле мы хотим найти определенный спектр цветов
    # Модель RGB нам в этом не поможет
    # Модель hsv позволит нам легко выделить спектры интересующих нас цветов
    # на вход мы подаём наш раш размытый кадр и константу, отвечающую за соответствующее преобразование (cv2.COLOR_BGR2HSV)
    frame_HSV = cv2.cvtColor( frame_blur, cv2.COLOR_BGR2HSV )

    # и теперь, та-да! вызов функции, что объявлена выше
    # вызывается для каждого цвета по отдельности
    #  
    # red
    findAndDrawContour( 
                        frame_HSV, frame, cnv,      # hsv, out, cnv
                        (0,200, 70), (7,255,255),   # clr_low, clr_high
                        (0,0,255)  )                # clr
    # orange
    findAndDrawContour( 
                        frame_HSV, frame, cnv,
                        (7,200, 70), (15,255,255),
                        (0,100,250) )
    # yellow
    findAndDrawContour( 
                        frame_HSV, frame, cnv,
                        (15,190, 70), (30,255,255),
                        (0,255,255) )
    # light green
    findAndDrawContour( 
                        frame_HSV, frame, cnv,
                        (30, 150, 40), (65,255,255),
                        (50,255,100))
    # green
    findAndDrawContour( 
                        frame_HSV, frame, cnv,
                        (65, 140, 10), (90,255,255),
                        (255,255,0))
    # blue
    findAndDrawContour( 
                        frame_HSV, frame, cnv,
                        (90, 120, 50), (140,255,255),
                        (255,0,0))
 
    # purple
    findAndDrawContour( 
                        frame_HSV, frame, cnv,
                        (150, 120, 20), (180,255,255),
                        (200,0,100))
    
    # показываем/обновляем окна 'paint' и 'camera', передавая им соответствующие массивы изображений
    cv2.imshow('paint', cnv)
    cv2.imshow('camera', frame)

    # эффект красивого затухания для холста
    # чтобы нарисованное красиво стиралось
    #
    # каждую итерацию цикла вычитает из массива холста 3 единицы (2 + 1)  там, где это возможно 
    #
    # закомментить эти 2 строчки, чтобы не  стиралось со временем
    # или добавьте/закоментите одну, чтобы манипулировать скоростью затухания
    cnv[ cnv > 2 ] -= 2
    cnv[ cnv  > 0  ] -= 1


    # в переменную key записывается значение символа с клавиатуры в соответствии с таблицей кодировки ascii
    key = cv2.waitKey(1)
    
    # если нажата клавиша ESC 
    if key == 27:
        # прерываем работу цикла 
        break
    
    # если нажата клавиша пробел
    if key == 32:
        # очищаем холст
        cnv *= 0

# по завершению работы программы 
# закрываем все окна, что эта программа создала    
cv2.destroyAllWindows()
# освобождаем камеру, чтобы та могла быть задействована в иных приложениях
cap.release()
